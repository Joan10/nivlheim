#!/usr/bin/perl
use strict;
use warnings;

use CGI;
use DBI;
use JSON;
use Log::Log4perl;
use Net::DNS;
use LWP::Simple;

sub parse_query_string();

# Restrict access to only localhost
my $ip = $ENV{'REMOTE_ADDR'};
if ($ip ne "127.0.0.1" && $ip ne "::1") {
	print "Status: 403\n";
	exit;
}

# Config
my $confdir = "/var/www/nivlheim";

# Logging
Log::Log4perl->init("$confdir/log4perl.conf");
my $logger = Log::Log4perl->get_logger();

# Connect to database
my %attr = ("AutoCommit" => 0, "RaiseError" => 0);
my $dbh = DBI->connect("dbi:Pg:", "", "", \%attr);
if (!$dbh) {
	print "Status: 500\nContent-Type: text/plain\n\n";
	print "Unable to connect to Postgres database:\n";
	print $DBI::errstr . "\n";
	$logger->error("Unable to connect to Postgres: " . $DBI::errstr);
	exit 1;
}

# Check parameters
my %params = parse_query_string();
unless (exists $params{'fileid'}) {
	print "Status: 400\n\nMissing parameter: fileid\n";
	exit;
}
my $fileid = int($params{'fileid'});
if ($fileid ne $params{'fileid'}) {
	print "Status: 400\n\nfileid must be numeric\n";
	exit;
}

eval{
	$dbh->{RaiseError} = 1;

	my $row = $dbh->selectrow_hashref("SELECT filename, content, " .
		"received, is_command, certcn, ipaddr, certfp, clientversion, " .
		"os_hostname FROM files WHERE fileid=?", undef, $fileid);

	# Update lastseen and client version
	my $rowcount = $dbh->do("UPDATE hostinfo SET lastseen=?,clientversion=? ".
		"WHERE certfp=?", undef, ($row->{'received'}, $row->{'clientversion'}));
	if ($rowcount == 0) {
		# Insert a row where hostname is null. It will be filled in later,
		# by a system service. While hostname is null, this row will not
		# be visible through the API.
		$dbh->do("INSERT INTO hostinfo(lastseen,ipaddr,clientversion,"
				."os_hostname,certfp) VALUES(?,?,?,?,?)", undef,
				($row->{'received'}, $row->{'ipaddr'}, $row->{'clientversion'},
				$row->{'os_hostname'}, $row->{'certfp'}));
		# Trigger the system service to speed up the process
		# (It would have caught it eventually anyway)
		get("http://127.0.0.1:4040/api/v0/triggerJob/handleDNSchangesJob");
	} else {
		# The row exists already. This statement will set dnsttl to null only if
		# ipaddr or os_hostname changed.
		$dbh->do("UPDATE hostinfo SET ipaddr=?, os_hostname=?, ".
		 	"dnsttl=null WHERE (ipaddr!=? OR os_hostname!=?) AND certfp=?",
			undef, ($row->{'ipaddr'}, $row->{'os_hostname'},
				$row->{'ipaddr'}, $row->{'os_hostname'}, $row->{'certfp'}));
	}

	# Different files must be parsed differently
	if ($row->{'filename'} eq "/etc/redhat-release") {
		my ($os, $os_edition);
		if ($row->{'content'} =~ /^Red Hat Enterprise Linux (\w+).*Tikanga/) {
			$os = 'RHEL 5';
			$os_edition = $1;
		}
		elsif ($row->{'content'} =~ /^Red Hat Enterprise Linux (\w+).*Santiago/) {
			$os = 'RHEL 6';
			$os_edition = $1;
		}
		elsif ($row->{'content'} =~ /^Red Hat Enterprise Linux (\w+).*Maipo/) {
			$os = 'RHEL 7';
			$os_edition = $1;
		}
		elsif ($row->{'content'} =~ /^Fedora release (\d+)/i) {
			$os = "Fedora $1";
		}
		elsif ($row->{'content'} =~ /^CentOS Linux release (\d+)/) {
			$os = "CentOS $1";
		}
		my $sth;
		if (defined($os_edition)) {
			$sth = $dbh->prepare("UPDATE hostinfo SET os=?, os_edition=? WHERE certfp=?");
			$sth->execute(($os, $os_edition, $row->{'certfp'}));
		} else {
			$sth = $dbh->prepare("UPDATE hostinfo SET os=? WHERE certfp=?");
			$sth->execute(($os, $row->{'certfp'}));
		}
		$sth->finish;
	}

	if ($row->{'filename'} eq "/usr/lib/os.release.d/os-release-workstation") {
		my $os_edition = 'Workstation';
		my $sth = $dbh->prepare("UPDATE hostinfo SET os_edition=? WHERE certfp=?");
		$sth->execute(($os_edition, $row->{'certfp'}));
		$sth->finish;
	}

	if ($row->{'filename'} eq "/usr/lib/os.release.d/os-release-server") {
		my $os_edition = 'Server';
		my $sth = $dbh->prepare("UPDATE hostinfo SET os_edition=? WHERE certfp=?");
		$sth->execute(($os_edition, $row->{'certfp'}));
		$sth->finish;
	}

	if ($row->{'filename'} eq "/usr/lib/os.release.d/os-release-cloud") {
		my $os_edition = 'Cloud';
		my $sth = $dbh->prepare("UPDATE hostinfo SET os_edition=? WHERE certfp=?");
		$sth->execute(($os_edition, $row->{'certfp'}));
		$sth->finish;
	}

	if ($row->{'filename'} eq "/usr/bin/dpkg-query -l") {
		my $os_edition;
		if ($row->{'content'} =~ /ubuntu-desktop/) {
			$os_edition = 'Desktop';
		} elsif ($row->{'content'} =~ /ubuntu-server/) {
			$os_edition = 'Server';
		}
		if (defined($os_edition)) {
			my $sth = $dbh->prepare("UPDATE hostinfo SET os_edition=? WHERE certfp=?");
			$sth->execute(($os_edition, $row->{'certfp'}));
			$sth->finish;
		}
	}

	if ($row->{'filename'} eq "/etc/debian_version") {
		if ($row->{'content'} =~ /^(\d+)\./) {
			my $os = "Debian $1";
			my $sth = $dbh->prepare("UPDATE hostinfo SET os=?, "
						."os_edition=null WHERE certfp=?");
			$sth->execute(($os, $row->{'certfp'}));
			$sth->finish;
		}
	}

	if ($row->{'filename'} eq "/etc/lsb-release") {
		if ($row->{'content'} =~ /DISTRIB_ID=Ubuntu.*DISTRIB_RELEASE=(\d+)\.(\d+)/s) {
			my $os = "Ubuntu $1.$2";
			my $sth = $dbh->prepare("UPDATE hostinfo SET os=? "
						."WHERE certfp=?");
			$sth->execute(($os, $row->{'certfp'}));
			$sth->finish;
		}
	}

	if ($row->{'filename'} eq "/usr/bin/sw_vers"
			&& $row->{'content'} =~ /ProductName:\s+Mac OS X\nProductVersion:\s+(\d+\.\d+)/) {
		my $os = "macOS $1";
		my $sth = $dbh->prepare("UPDATE hostinfo SET os=?, "
					."os_edition=null WHERE certfp=?");
		$sth->execute(($os, $row->{'certfp'}));
		$sth->finish;
		# There is a product called macOS Server, but I don't know how to
		# distinguish it from the "plain" macOS.
		# https://en.wikipedia.org/wiki/MacOS_Server
	}

	if ($row->{'filename'} eq "(Get-WmiObject Win32_OperatingSystem).Caption") {
		my $s = $row->{'content'};
		my ($os, $os_edition);
		if ($s =~ /Microsoft Windows 7/) {
			$os = 'Windows 7';
		}
		elsif ($s =~ /Microsoft Windows 10/) {
			$os = 'Windows 10';
		}
		elsif ($s =~ /Microsoft Windows Server 2008 R2/) {
			$os = 'Windows 2008 R2';
			$os_edition = 'Server';
		}
		elsif ($s =~ /Microsoft.+Windows.+Server.+2008.+(Standard|Enterprise)/) {
			$os = 'Windows 2008';
			$os_edition = 'Server';
		}
		elsif ($s =~ /Microsoft Windows Server 2012 R2/) {
			$os = 'Windows 2012 R2';
			$os_edition = 'Server';
		}
		elsif ($s =~ /Microsoft Windows Server 2012/) {
			$os = 'Windows 2012';
			$os_edition = 'Server';
		}
		elsif ($s =~ /Microsoft Windows Server 2016/) {
			$os = 'Windows 2016';
			$os_edition = 'Server';
		}
		my $sth;
		if (defined($os_edition)) {
			$sth = $dbh->prepare("UPDATE hostinfo SET os=?, os_edition=? WHERE certfp=?");
			$sth->execute(($os, $os_edition, $row->{'certfp'}));
		} else {
			$sth = $dbh->prepare("UPDATE hostinfo SET os=? WHERE certfp=?");
			$sth->execute(($os, $row->{'certfp'}));
		}
		$sth->finish;
	}

	# kernel
	if ($row->{'filename'} eq "/bin/uname -a"
			&& $row->{'content'} =~ /(\S+) \S+ (\S+)/) {
		my $os = $1;
		my $kernel = $2;
		$dbh->do("UPDATE hostinfo SET kernel=? WHERE certfp=?", undef,
				($kernel, $row->{'certfp'}));
		if ($os eq 'FreeBSD' && $kernel =~ /^(\d+)/) {
			$os = "FreeBSD $1";
			$dbh->do("UPDATE hostinfo SET os=? WHERE certfp=?", undef,
				($os, $row->{'certfp'}));
		}
	}

	if ($row->{'filename'} eq "[System.Environment]::OSVersion|ConvertTo-Json") {
		eval {
			my $content = decode_json($row->{'content'});
			my $v = $content->{'Version'};
			my $kernel = sprintf("%d.%d.%d.%d",
				$v->{'Major'}, $v->{'Minor'}, $v->{'Build'}, $v->{'Revision'});
			$dbh->do("UPDATE hostinfo SET kernel=? WHERE certfp=?", undef,
                ($kernel, $row->{'certfp'}));
		};
	}

	# dmidecode system information
	if ($row->{'filename'} eq "/usr/sbin/dmidecode -t system") {
		if ($row->{'content'} =~ /^System Information\n(.*?)^$/sm) {
			my $info = $1;
			my ($vendor, $model, $serial);
			if ($info =~ /Manufacturer: (.*?)\s*$/m) {
				$vendor = $1;
				$vendor =~ s/^HP$/Hewlett-Packard/;
				$vendor =~ s/HITACHI/Hitachi/;
			}
			if ($info =~ /Product Name: (.*?)\s*$/m) {
				$model = $1;
			}
			if ($info =~ /Serial Number: ([^\s]+)\s*$/m) {
				$serial = $1;
			}
			$dbh->do("UPDATE hostinfo SET vendor=?, model=?, serialno=? WHERE certfp=?",
				undef, ($vendor, $model, $serial, $row->{'certfp'}));
		}
	}

	# Model and vendor from Windows
	if ($row->{'filename'} eq "Get-WmiObject Win32_computersystemproduct|Select Name,Vendor|ConvertTo-Json") {
		eval {
			my $content = decode_json($row->{'content'});
			$dbh->do("UPDATE hostinfo SET model=? WHERE certfp=?",
				undef, ($content->{'Name'}, $row->{'certfp'}));
			my $vendor = $content->{'Vendor'};
			$vendor =~ s/^HP$/Hewlett-Packard/;
			$vendor =~ s/HITACHI/Hitachi/;
			$dbh->do("UPDATE hostinfo SET vendor=? WHERE certfp=?",
				undef, ($vendor, $row->{'certfp'}));
		};
	}

	$dbh->do("UPDATE files SET parsed = true WHERE fileid = ?",
		undef, ($fileid));
	$dbh->commit;
};
if ($@) {
	my $err = $@;
	$logger->error($err);
	if ($err =~ /prepare/) {
		$logger->error($dbh->{Statement});
	}
	$dbh->rollback;
	$dbh->disconnect;
	print CGI::header(
		-type => 'text/plain',
		-status => '500 Internal Server Error'
	);
	print $err;
	exit 1;
};

# Clean up
$dbh->disconnect;

# Return OK
print CGI::header('text/plain');
print "OK\n";

sub parse_query_string() {
	my %result = ();
	foreach (split /&/, $ENV{'QUERY_STRING'}) {
		my ($key, $value) = split /=/;
		$result{$key} = $value;
	}
	return %result;
}
